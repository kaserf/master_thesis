%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out
                                                          % if you need a4paper
%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4
                                                          % paper
%\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts                              % This command is only
                                                          % needed if you want to
                                                          % use the \thanks command
\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

% The following packages can be found on http:\\www.ctan.org
%\usepackage{graphics} % for pdf, bitmapped graphics files
%\usepackage{epsfig} % for postscript graphics files
%\usepackage{mathptmx} % assumes new font selection scheme installed
%\usepackage{times} % assumes new font selection scheme installed
%\usepackage{amsmath} % assumes amsmath package installed
%\usepackage{amssymb}  % assumes amsmath package installed
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}

\title{\LARGE \bf
ROSDashboard: a visual debugging tool for robotics
}

%\author{ \parbox{3 in}{\centering Huibert Kwakernaak*
%         \thanks{*Use the $\backslash$thanks command to put information here}\\
%         Faculty of Electrical Engineering, Mathematics and Computer Science\\
%         University of Twente\\
%         7500 AE Enschede, The Netherlands\\
%         {\tt\small h.kwakernaak@autsubmit.com}}
%         \hspace*{ 0.5 in}
%         \parbox{3 in}{ \centering Pradeep Misra**
%         \thanks{**The footnote marks may be inserted manually}\\
%        Department of Electrical Engineering \\
%         Wright State University\\
%         Dayton, OH 45435, USA\\
%         {\tt\small pmisra@cs.wright.edu}}
%}

\author{Felix Kaser$^{1}$, Bruce A.~MacDonald$^{2}$, Andreas Angerer$^{3}$% <-this % stops a space
%\thanks{*This work was not supported by any organization}% <-this % stops a space
\thanks{$^{1}$F. Kaser is a student in the Software Engineering Elite Graduate Program at University of Augsburg, Technische Universität München and LMU Munich.
        {\tt\small kaserf at in.tum.de}}%
\thanks{$^{2}$B. MacDonald is an Associate Professor at the Department of Electrical and Computer Engineering, University of Auckland,
        New Zealand.
        {\tt\small b.macdonald at auckland.ac.nz}}%
\thanks{$^{3}$A. Angerer is with with the Institute for Software and Systems Engineering, University of Augsburg, D-86135 Augsburg, Germany.
        {\tt\small angerer at informatik.uni-augsburg.de}}%
}

\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}

Data collected during debugging is traditionally rendered as text.
% For object oriented languages the properties are specified, but the final representation of data instances is still text. 
The special application field of robotics faces problems with this approach, since a typical robotic system constantly gathers and processes data from the surrounding environment through sensors. Robotic applications are also hard to interrupt during debugging, since robots generally don't run in a deterministic and suspendable environment. Developers of robotic applications are confronted with high amounts of data during debugging, which becomes hard to interpret if the data is represented as text and high amounts of data need to be interpreted at once. This paper introduces a new tool to support debugging of robotic applications: It takes into account the special requirements for a debugging tool in a robotic development environment, especially the uninterrupted rendering of debugging data and the need for better visualization of data to support a faster interpretation of data. The tool's goal is to help developers understand the data during debugging more quickly and improve overall productivity during robot development. A graphical user interface was developed where developers can choose how they want to visualize data collected during debugging.

%Debugging robotic systems is particularly complex due to the nature of data that is debugged. There is a gap between a high level data visualization tool like rviz and a low level message logging tool like rosconsole. The high level rviz tool is specialized for 3d visualization of complex data like robot arm movement, laser range data and point cloud data. rviz was not designed to visualize abstract data that is handled during the execution of a robot. Such data is often used to debug algorithms. To capture the data most developers use a printf-debugging style, often also logging frameworks. In ROS this can be achieved by using the core logging API, which sends messages containing the data to the special /rosout topic. Tools like rosconsole or rxconsole can be used to display those messages. While this data does not need complex 3d visualizations, it can still be useful to visualize the data in some way.

\end{abstract}

%** I put my comments with double asterisks. 

%** One general comment: about the style of the writing, it needs to be a bit more formal, less use of qualitative adjectives and cut out the words that are not adding to the key meaning of the sentence; some of the editing I did was for that ** 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCTION}

%Debugging is a complex topic, especially for robotic systems where the developer needs not only to deal with code complexity but also with a distributed environment. There are many different frameworks and hardware approaches, a standard is hard to define. Due to the complexity and the diversity of frameworks and hardware many developers build their own tools to assist them in the development and debugging of their applications\cite{Collett2010}.

%When debugging a robot a developer usually faces two main challenges: data acquisition and data visualization. This paper introduces a new tool for data visualization in robot applications and will shortly present different approaches to data acquisition. The goal of the tool is to improve the visualization of debugging data and give developers a generalized tool that can be easily adapted to different robot applications.

%Data acquisition has been addressed in previous work by Gumbley, where a framework was introduced to gather debugging data without interrupting the execution of a robot application\cite{Gumbley2009}.

Current debugging tools for robotics are mostly based on debugging techniques and interfaces developed for traditional non-robotic applications. Those techniques and interfaces were developed specifically to suit the requirements of traditional systems: First they assume that a program can be interrupted in its execution, which in a robotic environment is not possible most of the time. Second the data handled in traditional applications is usually discrete and based on user input, as opposed to the sensory data a robot handles. The data a robot handles is in general closely related to the real world environment of the robot and comes from sensors that provide a continuous data stream of readings. Although the computing world has changed in recent years, most tools have not. Robot developers often still use tools which were developed under different circumstances and based on different requirements. The application field of robotics has special requirements for debugging tools which are often not met by current debugging tools.

%We need better debugging tools to handle the special kind of data in robotics.
Traditional debugging tools usually render data collected during debugging as text and it's the developer's task to interpret the data. In a suspendable environment the developer has as much time as they need to interpret and analyse the data. When debugging robotic applications the developer usually has a lot less time, because of the nature of the application: Robotic applications usually can not be interrupted in their execution, because robots generally don't run in a deterministic and suspendable environment \cite{Gumbley2009}. Interrupting a robotic application would destroy the continuity in which the sensors collect data, the environment of the robot would change substantially and thus the robot's behaviour would change, which is an example of the ``probe effect'' and makes it hard to reproduce a fault unless it has a single cause \cite{Gumbley2009}. It is necessary to collect data during debugging without interrupting the execution of the program. Although some technical solutions have been presented in recent years \cite{Gumbley2009}, many developers still rely on printf-style debugging or other logging mechanisms. This approach is much simpler and does not require external tools, but the source code must be modified. Source code modification can be a problem with so called "Heisenbugs", software faults that disappear because the observation affected the bug \cite{Grottke2005}. The data collected with print or logging statements is usually text-only, which requires the developer to constantly parse and interpret logging messages. Due to the large amount of data that is processed this often means developer consoles are filled with logging messages that often contain more complex content such as numeric data.

ROSDashboard, the tool presented in this work, aims to support the developer during debugging by visualizing data in a graphic way and thus eliminating the cognitive effort needed to parse and interpret text based logging messages. While most of the currently available visualization tools in robotics focus on spatial data to help understand the robot and the environment in which it runs \cite{Collett2010, Quigley2009}, rendering of abstract data is still uncommon. ROSDashboard provides a dashboard interface to robot developers, which they can populate with graphical widgets to visualize all kinds of data from the robot. The dashboard can be customized to display widgets according to the current robot hardware and development stage. It can be used to visualize data during debugging as well as monitor data during the normal execution of the robot. This means ROSDashboard is a tool that a) can be adapted to many different use cases and b) allows the developer to choose the widgets he or she thinks represent the data best, according to their mental model and the meaning of the data. The tool is based on ROS (Robot Operating System) which abstracts from specific robot hardware and takes care of inter process communication \cite{Quigley2009}.

\newpage

% [drop next sentence?]In past research visualization has been successfully used to reduce the cognitive effort to understand the structure of a computer program \cite{Tudoreanu2003} [questionable citation.], with the tool presented in this paper a first step towards the evaluation of the impact of data visualization on the cognitive effort during debugging has been made.


% [next part is experimental] The tool presented in this paper tries to apply the same principles to debugging. [Hypothesis:] Visualizing data in a way that fits the developers expectations and mental model reduces the cognitive effort needed to understand the data [cite!]. Using visualizations during the debugging process can help developers to interpret and understand the data much faster [this is actually the hypothesis, still to be evaluated in the future], without the need of interrupting the execution of a robot application.

%ROSDashboard, the tool presented in this paper, is designed for robot development in general and not specific to one application area. The goal was to create a visualization tool that can be used for many different robot applications and is easy to adapt, in case developers want to use it for a specific use case where the default implementation is not sufficient.
%Developers face a different set of challenges when developing and debugging robotic systems instead of traditional software systems \cite{Collett2010, Collett2006, Gumbley2009}. Debugging is a complex task that generally consists of data acquisition and data visualization.
%In traditional software systems the data visualization is mostly rendered text. Although it might not be the best representation for data, text definitely is the most unified representation and is therefore a good choice for traditional software systems that deal with every kind of data.
%When developing applications for robots, this proves to be a challenge. Robots usually handle sensory data which is highly related to the environment where the robot operates. Traditionally this data is represented as text. This paper presents a new approach to visualize simple data when debugging a robot. Current solutions and problems with those solutions are outlined and a new tool is introduced to take care of the data visualization.

%Interpreting and understanding debugging data is much faster if the data is represented in a way that a) is natural in respect to the type of data and b) fits the mental model of the developer. Some research has been conducted in the direction of augmented reality (AR) debugging \cite{Collett2006, Collett2010}. Augmented reality debugging [tries to?] bridges the gap in the perception of the world from a human (developer) point of view and a robot point of view. ARDev, the system introduced in \cite{Collett2010} only focuses on visual representation of global perception data like laser-range data, path visualizations, ...
%The tool presented in this paper addresses visualization of abstract data, which was identified as possible future work in \cite{Collett2010}.

%The field of robotics consists of really diverse hardware solutions for different kinds of problems. This lead to high number of frameworks and tools for robot development without a clear standard. Due to the complexity and the diversity of frameworks and hardware many developers build their own tools to assist them in the development and debugging of their applications\cite{Collett2010}, which contributes even more to the fragmentation of frameworks and tools.
%The goal for the tool presented in this work was to be customizable and adaptable to different kinds of robots and projects, in order to be a useful tool to as many developers as possible. This was one of the main requirements and is described in more detail in section \ref{requirements}.

%Data acquisition in robotic environments is difficult due to ``the robot environment, the inherent nature of mobile robots, and the nature of mobile robot tasks''\cite{Collett2010}. [wrong citation, does not refer to data acquisition]

% Debugging robotic systems has proven to be more difficult than debugging generic computer systems [check citation!] \cite{Collett2010}. Developers face the challenge of data acquisition and data visualization. Acquiring data in a robot environment can be difficult because normal debugging approaches such as breakpoints are infeasible, because interrupting the robot during runtime can alter the state of the robot in a way that 

% One of the biggest problems when debugging robotic systems is the non-interruptible nature of robotic applications. Sometimes it is hard or even impossible to interrupt the execution of a robot without the danger of damaging the robot hardware or putting the people in the surroundings at risk. ** need to be more specific than ``threat''; what exactly do you mean? ++ better? ** For example you can not just interrupt a quad-copter in mid-flight to step through the algorithm to find a bug. [citation? rewrite? drop the example?]

%One approach is to design two separate controllers: a low level controller that keeps the essential parts of the robot running (e.g. keep the quad-copter flying) and a high level controller that runs the application logic code which is debugged. This only solves part of the problem because developing the low level controller is still not interruptible. [citation?] and because the application logic may need to respond to external inputs at any time.

%---> this could go into related work (data acquisition)
%Another approach is the concept of tracepoints for debugging a robot application without interrupting the execution but analysing the trace either after the application finishes, or viewing the results live \cite{Gumbley2009}. Tracepoints are a highly instrumented way of debugging and do not require modifications to the source code.
%A less instrumented method of debugging still used by many developers [no numbers to prove that, could not find any studies] is so called printf-debugging. Print statements are used to collect and output values during the execution of a program which can be viewed either live or after the application finished. Using printf-debugging is highly flexible and easy but it requires source code modifications and it can be difficult to keep track of print statements in bigger applications. In higher languages (and frameworks) this method is often supported by tools and can be refactored out of release compilation units for optimization. [for example android logcat and log4j in general, should I be more specific?]

%One issue that still remains with all of the above methods is the representation of data. All of the methods represent data as text and it can be [it is? whats the correct wording here?] hard to interpret the different values. [@ bruce: OK this needs some work, I'm trying to write down what I would like to express, maybe you can help me to find better (more scientific) words for it or tell me to drop it completely]. Interpreting and understanding data is much faster if the data is represented in a way that a) is natural in resprect to the type of data and b) fits the mental model of the developer. Some research has been conducted in the direction of augmented reality (AR) debugging \cite{Collett2006} \cite{Collett2010}. Augmented reality debugging [tries to?] bridges the gap in the perception of the world from a human (developer) point of view and a robot point of view. ARDev, the system introduced in \cite{Collett2010} only focuses on visual representation of global perception data (laser data, path visualizations, ...) and visualization of abstract data was identified as possible future work in \cite{Collett2010}.

%This paper presents a new tool to visualize abstract and algorithm-local data: ROSDashboard. The tool visualizes data collected with a printf-style approach [how do I say that printf-style was chosen because it was the fastest way to access data for the prototype? Should I drop it here and write about it in the requirements/design?] and the developer can arrange widgets on a dashboard to visualize the debugged data in a more natural way. The developer can choose which visualization he or she prefers and best suits his or her mental model of the data. The goal of the tool is to further improve debugging data visualization and debugging in general.
%[drop next sentence]However the tracepoint approach is complex and pre-execution configuration takes a substantial effort and skill, which many developers won't like to take upon them. [badly written, rewrite, no proof** I tried to improve the writing; however I agree there is no proof of the substantial effort and I don't believe it either! need to be more precise and exact about the issues]

%[@ bruce: I am thinking of dropping this paragraph in favour of a different approach (the one above)]Because of the problems stated above many developers still use printf-debugging [proof?] It is something they can use with the skills they already have, without learning a new toolset and setting up a tracing or debugging chain[proof?]. One major downside of printf-style-debugging is the text-only representation of data. Although the developers might be used to looking at and interpreting numbers scrolling down in a console window, it is not a very natural representation of the data. This paper [we or I? ** neither unless its important to the argument; just stick with the info to be presented, as I changed it to **] presents a new approach to improve printf-style-debugging with a new tool: ROSDashboard. The tool visualizes data collected with a printf-style approach and the developer can arrange widgets on a dashboard that visualize the debugged data in a more natural way. The developer can choose which visualization he or she prefers and best suits his or her mental model of the data. [unnecessary?: While printf-debugging has its downsides, there are also benefits to printf-debugging. The developer knows exactly where the printf-statements are and this makes it easy to understand the flow of a program.]


%** Goal of the work needs to be stated concretely and specifically; something clear and strong. Did the proposal provide that? Else there is nothing to hang the background and requirements on ** [is this better now?]

\section{ROS - Robot Operating System}
\label{ros}

%** this next bit is not really relevant to the paper; why not talk about its debugging capabilities **
%The first work on ROS was done as part of the STanford Artificial Intelligence Robot (STAIR) in 2007 \cite{Quigley2007}. The original software library was called \emph{Switchyard} and had been developed at Stanford. Later the library was refined and generalized to also suit the requirements of the Personal Robot Program at Willow Garage\footnote{www.willowgarage.com} \cite{Quigley2009}. The resulting general framework has been released as Open Source \cite{Quigley2009} and a community of researchers and industry partners has grown that supports and keeps developing the framework.
%** previous bit is not so relevant here **

%** This paragraph is more relevant I think. I think it needs some addition to explain why its relevant and how it relates to debugging **
ROS is an Open Source framework for complex robotic systems which has grown significantly in the last years, has an active community backing the project and supports many of the currently available robots \cite{Foote2012}. It was developed to abstract from the hardware of the robot and make it easier to create modular robot software, which can run on different robots and on different machines. The modular approach makes development easier, because the work can be divided amongst different developers or development teams. This also allows the developer to change only small parts of a complex system, without the need to build and re-deploy the whole system.
The modules in ROS are called \emph{nodes} and several nodes executed together are called a \emph{stack}. ROS \emph{packages} bundle nodes and stacks and are used to make software modules available to other developers. Everyone can create their own package which can be indexed by ROS so that their software modules can be found, downloaded and used by other developers. There exist many packages, nodes and stacks with implementations of algorithms for some of the most common problems in robotics (e.g. navigation, localization, joint movement, etc.) and they can easily be (re-)used.

%** again, state the relevance to debugging **
The communication between ROS nodes is either asynchronous through a publish/subscribe mechanism or synchronous through services. Nodes can send messages by publishing a message on a topic and receive messages by subscribing to that topic. This mechanism is flexible and decouples the sender from the receiver. A publisher node does not need to know if there are other nodes listening and vice versa. For synchronous communication and guaranteed delivery of messages, services can be invoked. The routing is established during runtime through the ROS core. The communication between nodes is one of the main sources for debugging data when debugging a ROS application. The same communication framework is also used for the logging mechanism in ROS, which publishes messages to the special purpose topic \emph{/rosout}.
% The core of ROS was kept really slim and only contains the most essential parts of the framework (such as the inter node communication). ROS can run on several machines distributed in a network, the only restriction is that every node needs to know the address of the core (master node) in order to communicate with other nodes.

ROS comes with several tools to assist the developers during the development and debugging of a robot. The tools most relevant to this work are:
\begin{description}[\setlabelwidth{rxconsole}]
\item[rostopic] a command line tool to monitor topics and publish messages on topics.
\item[rxplot] a graphical tool which plots data from one or more topic fields on a cartesian coordinate system.
\item[rxconsole] displays logging messages that have been published on the special purpose topic \emph{/rosout}.
\item[rviz] renders models of the robot in 3D and visualizes spatial data like point clouds, robot poses, trajectories, etc. \cite{Quigley2009}.
\end{description}

%rostopic and rxconsole display logging messages as text. Their purpose is not to visualize data but to assist the developer during the development as a logging framework. rxplot is designed to visualize data on a cartesian coordinate system, which is mostly useful for measurements and not for data visualization. rx
%rviz was created because it is extremely hard to understand what is going on in the robots environment by only looking at numbers. --> point out that more abstract data is not visualized at all, thus the need for rosdashboard.


\section{RELATED WORK}

This section first gives an overview of existing visualization tools which are used in robot development frameworks. LabVIEW's visualization tools are presented as an example of a flexible visualization interface which can be used for many different application areas, not only robotics. Finally a novel way to capture data during debugging is presented.

\subsection{Visualization Tools in Robotics}
Most of the currently available robot frameworks have their own tools for data visualization. Player/stage \cite{Gerkey2003} contains a tool playerv, ORCA \cite{Makarenko2006} has the tools OrcaView2d and OrcaView3d, CARMEN \cite{Montemerlo2003} features a graphical interface called robotgui that enables control of the robot and visualization of data collected through sensors. All of these tools focus on visualization of pre-defined data collected from known interfaces such as laser sensors, mapping algorithms and computer vision modules. They were not developed to visualize arbitrary and abstract data which is often used for debugging.

ROS has two tools to visualize data. The simpler one is rxplot, which plots values as a time series on a cartesian coordinate system. rviz is a more complex tool to visualize spatial data in 3D. It was designed to render 3D models of robots together with data from sensors and algorithms: point cloud data, laser data, marker positions, arm postures, planned paths, etc. rviz has a plugin system which can be used to add further visualizations and modules.

ARDev is an augmented reality (AR) debugging system based on Player/Stage \cite{Collett2010}. The AR approach to debugging helps the developer to understand the global state of the robot by augmenting a video feed of the robot with information of the robots' perception. Like the tools presented above, it focuses on pre-defined data such as laser and sonar sensors. The visualization of abstract data has been identified as possible future work \cite{Collett2010}. Initial evaluation studies were promising that the visualization can help developers significantly during debugging \cite{Collett2010}.

3D visualizations such as rviz and ARDev are used during debugging to understand the robot's view of the world. Both of them require a substantial amount of set up work. For rviz a 3D model of the robot must be created, which has the exact proportions of the real robot. ARDev requires an even more complex setup for AR. During the development of the tool an intelligent debugging space (IDS) was permanently installed in a laboratory, where the robot under development can be constantly tracked with markers and cameras \cite{Collett2010}. This setup is often unavailable, especially in outdoor situations, and is also often not applicable for debugging tasks where only abstract data is available or required. A general problem with 3D visualization tools is that abstract data often does not fit into the 3-dimensional rendering and in the case of AR can hide important information of the real world \cite{Collett2010}.

\subsection{LabVIEW}

LabVIEW (Laboratory Virtual Instrumentation Engineering Workbench) is a graphical programming environment developed by National Instruments\footnote{http://www.ni.com}. It features \emph{Front Panels} which allow a developer to add widgets to a graphical interface. These widgets can display the status of the graphical program or act as control interface (button, knobs, etc.) for the program. For each widget on a panel an element is created in the block diagram of the program which can be connected to other parts in the block diagram. LabVIEW delivers a high number of pre-defined visualization widgets such as text displays, sliders and progress bars, which can be used to create a dedicated user interface for an application. This user interface can be used to control the application as well as monitor and debug the application.
%LabVIEW is released under a closed source license and does not allow developers to create their own widgets, which makes it hard to adapt to more complex use cases where specialized graphical widgets are required.

%LabVIEW integrates dedicated debugging tools that allow e.g. single-stepping through program execution and at the same time visualizing textual values of data flowing through the graphical program in each execution step. This single-step execution relies on the suspendability of programs, which is not always given for robot systems. Furthermore, data values can usually only be observed using a textual representation, which requires correct interpretation by the user.

The front panel feature was described as ``LabVIEW's biggest advantage,'' its ``best feature,'' or its ``main power'' in the open-format answers of a survey of LabVIEW programmers \cite{Whitley2001}. It would be possible to design concrete front panels also for the purpose of debugging a specific application. This however requires integrating each front panel element directly into the visual program and is thus highly intrusive. Though a more transparent debugging possibility would be desirable, LabVIEW shows the potential of a flexible tool for visualization of abstract data in form of graphical widgets.

\subsection{Tracepoints}
The non-interruptible nature of robotic applications is a challenge when it comes to data collection for debugging. Real time constraints make it even more difficult to collect data. Tracepoints have been investigated as a technology to collect data for debugging without interrupting the execution of a program \cite{Gumbley2009}. The tracepoints approach does not require source code modification and can also be used in real time critical systems.

%[I am already talking about the solution here, but I'm not sure where else to put it and it seems like important information to me.]

%In ROS a logging framework can be used to collect data for debugging. Internally the same mechanism for inter process communication is used also for log messages. The log messages emitted through the ROS logging framework are published on the special purpose \emph{/rosout} topic. The current implementation of the logging mechanism only allows text messages to be published, which means that useful information for debugging is potentially lost.

%In distributed environments such as ROS, the communication between modules is also a potential source of data for debugging. This kind of data is available all the time, because it is critical to the operation of modules.


\section{ROSDASHBOARD}

%\subsection{Overview}

The purpose of the tool presented in this paper is to support developers of robot applications during development and debugging. Current visualization tools specialize on visualizations for pre-defined data with a fixed structure, such as laser data, mapping information and path planning. ROSDashboard bridges the gap between existing visualization tools and low level text representations of data such as logging frameworks or print statements. The tool provides a graphical user interface for easy visualization of data streams. It uses the inter process communication platform of ROS to gather data for visualizations. This can be either existing data from module to module communication or new data specifically published for debugging. 
Although tracepoints could be a data provider for a visualization tool like ROSDashboard, for the scope of the first iteration of the tool we decided to use logging statements to collect data. Since the tool is based on ROS, which is not a real time operating system, the real time constraints were considered out of scope for this work.

The main interface of ROSDashboard is a central dashboard where developers can add visualization widgets through drag and drop from a toolbox. Currently a number of basic widgets have been implemented to visualize data, the tool's design though allows easy integration of more complex widgets. Fig.~\ref{screenshot} shows ROSDashboard's main interface with an example configuration of widgets on the dashboard.

\begin{figure}[thpb]
  \centering
  \framebox{
    \includegraphics[scale=0.35]{images/rosdashboard_screenshot.png}
  }  
  \caption{Screenshot of ROSDashboard's main interface.}
  \label{screenshot}
\end{figure}

\subsection{Requirements}
\label{requirements}

The requirements for ROSDashboard are derived from the special robotics needs for a debugging tool. When debugging robotic applications it is usually not possible to interrupt the execution of the application and follow a step-through approach. All data must be captured, processed and visualized live. The tool is designed for mobile robots, which means the communication is usually distributed across a network. % --> gather data through messages on existing and new topics (point out that ros logging cannot be used due to the text only data. Future work should fix this with regex parsing.)

Due to many different application scenarios in robotics and the diverse environment of available frameworks for robot development, many researchers and developers have built their own tools to support them during debugging \cite{Collett2010}. Developing your own debugging tool is extremely time consuming and the developed tools are often one-time-only tools, because they don't fit the use case of other applications and are too hard to adapt to a new project.
In order to allow the use of this tool in many different scenarios and use cases, flexibility has a high priority. Flexibility not only means the tool can be adapted easily to fit different problems, it also means the tool can be adapted to suit different developer's preferences. Each developer might prefer a different set of widgets to visualize the collected data, thus loose coupling of the collected data and the visualization widgets is necessary. % --> this is solved by using ros topics, they decouple sender and receiver

Debugging robotic applications is a highly iterative process, where small changes are made and immediately deployed to the robot. The debugging tool should keep the configuration overhead as minimal as possible so that the developer is not distracted from the problem analysis task. Adding and removing new widgets to ROSDashboard should not require many steps, otherwise the developer will be distracted by the configuration task. % --> the topic introspection process should keep configuration to a minimum

%** Section is pretty weak. Maybe refer back to the proposal and give clear and strong list of requirements; and they should be argued from the original goals of the work. And so the goal needs to be stated clearly and strongly above at the start.**

%[the requirements below are all quite high-level. should I add requirements like distributed debugging, uninterrupted debugging? they affected the design but distributed debugging is completely in ROS hands (it still affected the decision to go with ROS) ** yes, somewhere list them and say that ROS provides them. It is important here to explain the options and reasoning for design decisions. ** ]

%\subsubsection{Openness}
%One of the requirements is to be open. Open in terms of Open Source but also regarding the other requirements like extendibility and adaptability. Openness helps to spread the word and gain a higher user base faster. [citation?] [badly written. rewrite. ** yes need to be clear and precise and relevant. ]
%\subsubsection{Low configuration overhead}
%The goal was to create a useful tool that is easy to use and can be used by anyone without much configuration, setup or learning overhead. This contributes to a high user acceptance and a low entrance barrier [better wording?] for new users.
%\subsubsection{Extendibility and adaptability}
%Especially in robotics common standards are not yet defined and the variety of tools, frameworks and robot hardware is big. This means that the developed tool needs to be highly flexible. It should be easy to adapt the current system to work with any robot hardware supported by ROS and it should be designed with an open mind towards other frameworks. It also needs to be easy to reflect possible changes in the framework and underlying tools.
%\subsubsection{Follow the ROS philosophy [really?]}
%ROS is designed to have a really small core with as many tools build around the common core as needed. The principle is to have small tools that do one thing only but are really specialized and sophisticated in what they handle. This philosophy is followed and encouraged by the ROS core developers. It is important to follow this principle to reach a high acceptance among the ROS community and to fit in as good as possible with other tools.
%\subsubsection{Integrable}
%[explain current efforts of RQT and that rosdashboard should become part of it to be in the graphical ROS toolchain, but it was a moving target thus the integration is not done yet]
%\subsubsection{Customization [flexibility?]}
%Different developers prefer to visualize their data differently and every project is different. It is important [why important?] to create a system that can be customized by a developer to suit their preference and the targeted project best. [extend?] [put in citation from collett \cite{Collett2007}]


\subsection{Design}

%The tool presented in this paper fills the gap between a textual representation of data (rostopic, rxconsole) and a highly sophisticated 3D visualization of spatial data (rviz). rxplot is already positioned in between the textual and 3D visualization tools, but it offers only one form of visualization: a time graph.

%The ROS communication structure is used by ROSDashboard to connect the logging statements in the source code with the visualization on the dashboard. This allows to re-use existing data streams published on topics without introducing changes to the source code. If new data needs to be collected, the source code needs to be modified to publish the data to a topic. 
%The use of ROS topics to collect data for the debugging visualization allows ROSDashboard to access data transparently during runtime. Two scenarios of data collection can be distinguished:
%\begin{description}[\setlabelwidth{Debugging data}]
%\item[Long term] Data that is already published on topics for inter-module communication purposes or logging purposes. This data can be accessed and visualized without the need of source code modifications.
%\item[Debugging data] Data which is only used for debugging purposes. This kind of data is often used by developers to get an overview over the execution steps of an algorithm and is usually removed after a problem has been successfully debugged. This method requires source code modification and is mostly used in early development stages, where the source code is changed constantly anyway.
%\end{description}

ROS is used to abstract from the robot's hardware and to decouple the collection of debugging data from the visualization. As explained in section \ref{ros}, the ROS publish/subscribe mechanism is able to decouple the sender from the receiver of messages. ROSDashboard can access any data published on ROS topics: data that is used to communicate between different nodes and data that is specifically published for debugging purposes. This means ROSDashboard transparently accesses and visualizes data in existing projects without the need to modify the code, if the data is already published.

The current ROS logging framework publishes the log messages on the special purpose topic \emph{/rosout}, but converts everything to a String before the transmission. Since those logging messages are text based, valuable information about the type of the data is lost. To solve this problem temporarily, an API was exposed in ROSDashboard to provide a set of convenience methods which can be used to simply publish messages on a topic without loosing the type information. A more permanent solution that allows transparent data collection is discussed as future work (see section \ref{future}). % would need to be integrated into the current ROS logging framework to avoid having a dependency to ROSDahsboard in every debugging project.
%To collect data in the program a developer has to publish messages to a topic of their choice to which he can then connect the visualization to. To make this as easy as possible ROSDashboard exposes a simple API of convenience methods that can be used to publish data. The API takes care of the ROS specifics to create a message and publish the message on the topic specified by the developer.
If the developer chooses not to use the ROSDashboard API due to the new dependency to ROSDashboard, they can always publish the message manually. % point out in future work that this is not a optimal solution, because all projects that want to use rosdashboards API would need to add it as a dependency.

Although the current software does not support third party widgets yet, the internal structure of the widgets is aligned to allow easy integration of a plugin engine in the near future. For now if a third party wants to have specialized widgets, they need to modify the source code and add the code for widgets directly to the source tree. This is possible because ROSDashboard is developed as an Open Source project, the source code is hosted on Github\footnote{http://github.com/kaserf/rosdashboard}.

An early prototype was announced to the ROS community and valuable feedback has been collected and has been taken into consideration: small changes have already been implemented and bigger changes are documented as future work.

\subsection{Implementation details}

This section presents important implementation details. First the object model is presented: it has been designed to allow easy integration of a plugin framework in the future (see section \ref{future}).
Python was chosen as the target language for ROSDashboard, because it is a good match for fast prototyping and iterative development. Python's duck typing (``If it walks like a duck and quacks like a duck, it must be a duck'' \cite{Rozsnyai2007}) was used to minimize the configuration overhead when new widgets are added to the dashboard: Usually a datatype must be chosen, but through topic introspection the type was chosen dynamically (see \ref{topic introspection}). Minimizing the configuration overhead has been identified as a core requirement. Qt is used as graphical toolkit for ROSDashboard, which is currently the recommended toolkit for graphical tools in ROS.
%The ROSDashboard API shows how data can be published and connected to the visualization, it is a set of convenience methods which can be used as a reference implementation for developers who decide to publish the data themselves.

\subsubsection{Object model}

\begin{figure}[thpb]
  \centering
  \framebox{
    \includegraphics[scale=0.3]{diagrams/class_overview.pdf}
  }  
  \caption{Overview of the core object model structure.}
  \label{class overview}
\end{figure}

The object model (see Fig.~\ref{class overview}) was designed to make it easy to extend ROSDashboard with more widgets. The abstract \texttt{DashboardWidget} class covers the general tasks that are the same for every widget. Its internal method structure allows subclasses to overwrite only some parts of functionality, without the need to rewrite most of the other methods. This should allow easy integration of a plugin framework at a later stage, where third party widget developers only need to implement the specific parts of the new widget they want to provide and the common tasks are still handled by the default implementation in \texttt{DashboardWidget}.

The subscription setup and the properties management are implemented in the \texttt{DashboardWidget} class, because they will be the the same for most widgets. The main reason is to hide the technical details from a third party plugin developer to make his life easier. The plugin developer only needs to specify which properties his widget has and must implement the callback that gets called when the properties have been changed. The \texttt{DashboardWidget} supports numeric, text and float properties. If more specific properties are needed the plugin can overwrite the properties-specific methods to provide an implementation tailored to this specific widget.

\subsubsection{Topic introspection}
\label{topic introspection}

\begin{figure}[thpb]
  \centering
  \framebox{
    \includegraphics[scale=0.5]{images/topic_setup.png}
  }  
  \caption{Screenshot of the topic setup dialog.}
  \label{topic setup screenshot}
\end{figure}

ROS topics were originally not designed and developed as something the user or developer chooses graphically: They are usually created, configured and used in the source code. ROSDashboard exposes the topic setup in a graphical user interface every time a new widget is added to the dashboard. To make this as easy as possible and without much overhead, a technical solution was chosen to reduce the number of fields to be set during the topic subscription setup. Normally you have to select a topic name and a message data type. The data type can be one of the standard message types like Float, Integer, String and Boolean or a more complex message type which contains more information in a structured message. To access one data element of a message the ``datafield'' field was introduced in the graphical interface. Fig.~\ref{topic setup screenshot} shows an exemplary topic setup configuration to access the linear velocity of the \emph{/turtlesim/Velocity} message published to the topic \emph{/turtle1/command\_velocity}. Using Python's duck typing and the \emph{rostopic} module it was possible to avoid the complexity of dynamically binding message type classes during runtime and detect the message type automatically. If a topic is not yet published and thus the message type of this topic is not defined yet, the method call to \emph{rostopic} will block until the message type becomes available. To avoid blocking of the user interface a listener thread was implemented to wait until the message type for a topic becomes available (see Fig.~\ref{topic subscription}). Avoiding to manually ask the user for a message type makes the configuration of widgets easier and faster for the user, it also keeps the implementation significantly simpler, because no dynamic binding of message type classes during runtime is needed.

\begin{figure}[thpb]
  \centering
  \framebox{
    \includegraphics[scale=0.28]{diagrams/topic_subscription.pdf}
  }  
  \caption{Exemplary flow of events for asynchronous topic subscription setup.}
  \label{topic subscription}
\end{figure}

\section{Showcase}

Although the current implementation is a prototype, it has all the features that were initially planned. The implementation is running stably and first attempts to use it as a debugging tool have been made. ROSDashboard is ready to be used for the development of robot applications and can be used for further evaluations (see Section~\ref{future}).

Fig.~\ref{showcase} shows a simple showcase scenario: ROSDashboard is running alongside the \emph{turtlesim\_node} node which is used in many examples in the ROS tutorials\footnote{http://www.ros.org/wiki/ROS/Tutorials}. It monitors the values for linear and angular speed which are published by the \emph{turtle\_teleop\_key} node to control the turtle simulation. The String widget is configured to display messages from \emph{/rosout}, which in this example shows a warning when the turtle hits a wall.
For the purpose of this small showcase, there was no need to modify the turtlesim source code. The only topics used by the showcase scenario are topics that are already used to control the turtle in the simulation and to display warnings.

\begin{figure}[thpb]
  \centering
%  \framebox{
    \includegraphics[scale=0.28]{images/showcase3.png} % Scale was 0.26
%  }  
  \caption{ROSDashboard running alongside turtlesim\_node.}
  \label{showcase}
\end{figure}

Fig.~\ref{rosgraph_simple} shows the ROS computation graph during the execution of the showcase scenario. It shows how ROSDashboard is connected to the nodes which are debugged. The topics needed for the showcase are \emph{/turtle1/command\_velocity} for the linear and angular velocity and \emph{/rosout} for warnings when the turtle hit the wall.

%% \begin{figure}[thpb]
%%   \centering
%%   \framebox{
%%     \includegraphics[scale=0.23]{images/rosgraph.png}
%%   }  
%%   \caption{ROS computation graph with ROSDashboard.}
%%   \label{rosgraph}
%% \end{figure}

\begin{figure}[thpb]
  \centering
  \framebox{
    \includegraphics[scale=0.33]{diagrams/rosgraph}
  }  
  \caption{Simplified ROS computation graph with ROSDashboard.}
  \label{rosgraph_simple}
\end{figure}

\section{CONCLUSION AND FUTURE WORK}
\label{future}
% conclusion
ROSDashboard, the tool presented in this paper, is capable of visualizing simple abstract data that is being published on a topic in the ROS communication middleware. Although the tool presented in this work has not been fully evaluated yet, it shows the possibilities and potential of simple visualizations during debugging of robotic applications. Further evaluations need to be conducted in order to quantify the improvements the tool has on a reduced cognitive effort and thus debugging performance.

The modular design and Open Source approach followed during the development of the tool makes it easy to extend and adapt the tool in the future. It also allows developers to choose a representation of data they find most helpful, with the only restriction being the number of available widgets and the data type compatibility. The simple drag and drop principle to add and remove widgets on the dashboard makes the tool flexible towards changes during the debugging process.
% The feature to save and restore dashboard configurations makes it easy to distribute dashboards amongst the developers. This feature can also be used to provide monitoring dashboards that can be created by robot hardware manufacturers and given out to developers.

% future work
The presented tool is a first prototype to evaluate the use of a simple visualization tool during debugging. Further work can be done to increase the number of available widgets. Ultimately there should be a plugin engine where third party developers can easily add widgets for new and more complex kinds of data. The extensibility of the tool was one of the initial requirements and the structure of the program allows easy integration of such a plugin engine.

While the initial prototype's implementation of the topic setup dialog (Fig.~\ref{topic setup screenshot}) features simple text fields where the developer can enter arbitrary Strings, a more sophisticated solution can be implemented to improve the user interface. Using the existing ROS tools a list of available topics can be accessed, which makes it possible to create smarter interfaces. For example type-ahead completion for the topic name and a drop down list to choose the datafield parameter of a message are possible options.

Since the current logging mechanism in ROS transmits data as text, existing logging statements cannot be used as data source for the visualization. This can be resolved either by extending the logging mechanism to keep the type information of data or by implementing a parsing mechanism that can extract data which is embedded in text-based messages through regular expressions. This has been mentioned by the ROS community after the first prototype was announced. Another suggestion from the ROS community was to change the widgets to be more general and thus make it possible to have both visualization widgets and control widgets. This would give developers the ability not only to monitor values during execution but also manipulate configuration values and give commands to the robot during a debugging session.

RQT\footnote{http://www.ros.org/wiki/rqt} is a graphical interface that groups together many different graphical tools for ROS. It was under active development during the time of this project and it was chosen not to integrate ROSDashboard into RQT yet, but to keep it in mind for future work. The plugin interfaces to integrate a tool into RQT have been finalized recently and ROSDashboard can easily be integrated. This would allow developers to use ROSDashboard amongst other graphical tools in one unified graphical interface that saves the state of all tools when exited and work can be resumed where left of.

ROSDashboard provides a good base to conduct research on the impact of visualizations during debugging of robotic applications. Future research can evaluate how visualizations affect the developer during debugging, especially if it decreases the cognitive load and thus makes debugging with visualizations faster and more productive.

\addtolength{\textheight}{-12cm}   % This command serves to balance the column lengths
                                  % on the last page of the document manually. It shortens
                                  % the textheight of the last page by a suitable amount.
                                  % This command does not take effect until the next page
                                  % so it should come on the page before the last. Make
                                  % sure that you do not shorten the textheight too much.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

																																																																																																																															\section*{ACKNOWLEDGMENT}

																																																																																																																															This work is part of the final project in the Software Engineering Elite Graduate Program at University of Augsburg, Technische Universität München and LMU Munich\footnote{http://www.studieren.se}. It was conducted at the Department of Electrical and Computer Engineering, University of Auckland, New Zealand.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% references %%%%%
\bibliographystyle{IEEEtranBST/IEEEtran}
\bibliography{bibtex/Master_Thesis,bibtex/manual}

\end{document}
